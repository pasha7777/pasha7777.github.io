{
  "version": 3,
  "sources": ["../../workbox-cacheable-response/_version.js", "../../workbox-cacheable-response/CacheableResponse.js", "../../workbox-cacheable-response/CacheableResponsePlugin.js", "../../workbox-core/_private/dontWaitFor.js", "../../workbox-core/registerQuotaErrorCallback.js", "../../idb/build/wrap-idb-value.js", "../../idb/build/index.js", "../../workbox-expiration/_version.js", "../../workbox-expiration/models/CacheTimestampsModel.js", "../../workbox-expiration/CacheExpiration.js", "../../workbox-expiration/ExpirationPlugin.js", "../../workbox-recipes/_version.js", "../../workbox-recipes/googleFontsCache.js", "../../workbox-recipes/warmStrategyCache.js", "../../workbox-recipes/imageCache.js", "../../workbox-recipes/staticResourceCache.js", "../../workbox-recipes/pageCache.js", "../../workbox-core/_private/waitUntil.js", "../../workbox-precaching/_version.js", "../../workbox-precaching/utils/createCacheKey.js", "../../workbox-precaching/utils/PrecacheInstallReportPlugin.js", "../../workbox-precaching/utils/PrecacheCacheKeyPlugin.js", "../../workbox-precaching/utils/printCleanupDetails.js", "../../workbox-precaching/utils/printInstallDetails.js", "../../workbox-core/_private/canConstructResponseFromBodyStream.js", "../../workbox-core/copyResponse.js", "../../workbox-precaching/PrecacheStrategy.js", "../../workbox-precaching/PrecacheController.js", "../../workbox-precaching/utils/getOrCreatePrecacheController.js", "../../workbox-precaching/matchPrecache.js", "../../workbox-recipes/offlineFallback.js"],
  "sourcesContent": ["\"use strict\";\n// @ts-ignore\ntry {\n    self['workbox:cacheable-response:6.5.4'] && _();\n}\ncatch (e) { }\n", "/*\n  Copyright 2018 Google LLC\n\n  Use of this source code is governed by an MIT-style\n  license that can be found in the LICENSE file or at\n  https://opensource.org/licenses/MIT.\n*/\nimport { assert } from 'workbox-core/_private/assert.js';\nimport { WorkboxError } from 'workbox-core/_private/WorkboxError.js';\nimport { getFriendlyURL } from 'workbox-core/_private/getFriendlyURL.js';\nimport { logger } from 'workbox-core/_private/logger.js';\nimport './_version.js';\n/**\n * This class allows you to set up rules determining what\n * status codes and/or headers need to be present in order for a\n * [`Response`](https://developer.mozilla.org/en-US/docs/Web/API/Response)\n * to be considered cacheable.\n *\n * @memberof workbox-cacheable-response\n */\nclass CacheableResponse {\n    /**\n     * To construct a new CacheableResponse instance you must provide at least\n     * one of the `config` properties.\n     *\n     * If both `statuses` and `headers` are specified, then both conditions must\n     * be met for the `Response` to be considered cacheable.\n     *\n     * @param {Object} config\n     * @param {Array<number>} [config.statuses] One or more status codes that a\n     * `Response` can have and be considered cacheable.\n     * @param {Object<string,string>} [config.headers] A mapping of header names\n     * and expected values that a `Response` can have and be considered cacheable.\n     * If multiple headers are provided, only one needs to be present.\n     */\n    constructor(config = {}) {\n        if (process.env.NODE_ENV !== 'production') {\n            if (!(config.statuses || config.headers)) {\n                throw new WorkboxError('statuses-or-headers-required', {\n                    moduleName: 'workbox-cacheable-response',\n                    className: 'CacheableResponse',\n                    funcName: 'constructor',\n                });\n            }\n            if (config.statuses) {\n                assert.isArray(config.statuses, {\n                    moduleName: 'workbox-cacheable-response',\n                    className: 'CacheableResponse',\n                    funcName: 'constructor',\n                    paramName: 'config.statuses',\n                });\n            }\n            if (config.headers) {\n                assert.isType(config.headers, 'object', {\n                    moduleName: 'workbox-cacheable-response',\n                    className: 'CacheableResponse',\n                    funcName: 'constructor',\n                    paramName: 'config.headers',\n                });\n            }\n        }\n        this._statuses = config.statuses;\n        this._headers = config.headers;\n    }\n    /**\n     * Checks a response to see whether it's cacheable or not, based on this\n     * object's configuration.\n     *\n     * @param {Response} response The response whose cacheability is being\n     * checked.\n     * @return {boolean} `true` if the `Response` is cacheable, and `false`\n     * otherwise.\n     */\n    isResponseCacheable(response) {\n        if (process.env.NODE_ENV !== 'production') {\n            assert.isInstance(response, Response, {\n                moduleName: 'workbox-cacheable-response',\n                className: 'CacheableResponse',\n                funcName: 'isResponseCacheable',\n                paramName: 'response',\n            });\n        }\n        let cacheable = true;\n        if (this._statuses) {\n            cacheable = this._statuses.includes(response.status);\n        }\n        if (this._headers && cacheable) {\n            cacheable = Object.keys(this._headers).some((headerName) => {\n                return response.headers.get(headerName) === this._headers[headerName];\n            });\n        }\n        if (process.env.NODE_ENV !== 'production') {\n            if (!cacheable) {\n                logger.groupCollapsed(`The request for ` +\n                    `'${getFriendlyURL(response.url)}' returned a response that does ` +\n                    `not meet the criteria for being cached.`);\n                logger.groupCollapsed(`View cacheability criteria here.`);\n                logger.log(`Cacheable statuses: ` + JSON.stringify(this._statuses));\n                logger.log(`Cacheable headers: ` + JSON.stringify(this._headers, null, 2));\n                logger.groupEnd();\n                const logFriendlyHeaders = {};\n                response.headers.forEach((value, key) => {\n                    logFriendlyHeaders[key] = value;\n                });\n                logger.groupCollapsed(`View response status and headers here.`);\n                logger.log(`Response status: ${response.status}`);\n                logger.log(`Response headers: ` + JSON.stringify(logFriendlyHeaders, null, 2));\n                logger.groupEnd();\n                logger.groupCollapsed(`View full response details here.`);\n                logger.log(response.headers);\n                logger.log(response);\n                logger.groupEnd();\n                logger.groupEnd();\n            }\n        }\n        return cacheable;\n    }\n}\nexport { CacheableResponse };\n", "/*\n  Copyright 2018 Google LLC\n\n  Use of this source code is governed by an MIT-style\n  license that can be found in the LICENSE file or at\n  https://opensource.org/licenses/MIT.\n*/\nimport { CacheableResponse, } from './CacheableResponse.js';\nimport './_version.js';\n/**\n * A class implementing the `cacheWillUpdate` lifecycle callback. This makes it\n * easier to add in cacheability checks to requests made via Workbox's built-in\n * strategies.\n *\n * @memberof workbox-cacheable-response\n */\nclass CacheableResponsePlugin {\n    /**\n     * To construct a new CacheableResponsePlugin instance you must provide at\n     * least one of the `config` properties.\n     *\n     * If both `statuses` and `headers` are specified, then both conditions must\n     * be met for the `Response` to be considered cacheable.\n     *\n     * @param {Object} config\n     * @param {Array<number>} [config.statuses] One or more status codes that a\n     * `Response` can have and be considered cacheable.\n     * @param {Object<string,string>} [config.headers] A mapping of header names\n     * and expected values that a `Response` can have and be considered cacheable.\n     * If multiple headers are provided, only one needs to be present.\n     */\n    constructor(config) {\n        /**\n         * @param {Object} options\n         * @param {Response} options.response\n         * @return {Response|null}\n         * @private\n         */\n        this.cacheWillUpdate = async ({ response }) => {\n            if (this._cacheableResponse.isResponseCacheable(response)) {\n                return response;\n            }\n            return null;\n        };\n        this._cacheableResponse = new CacheableResponse(config);\n    }\n}\nexport { CacheableResponsePlugin };\n", "/*\n  Copyright 2019 Google LLC\n  Use of this source code is governed by an MIT-style\n  license that can be found in the LICENSE file or at\n  https://opensource.org/licenses/MIT.\n*/\nimport '../_version.js';\n/**\n * A helper function that prevents a promise from being flagged as unused.\n *\n * @private\n **/\nexport function dontWaitFor(promise) {\n    // Effective no-op.\n    void promise.then(() => { });\n}\n", "/*\n  Copyright 2019 Google LLC\n\n  Use of this source code is governed by an MIT-style\n  license that can be found in the LICENSE file or at\n  https://opensource.org/licenses/MIT.\n*/\nimport { logger } from './_private/logger.js';\nimport { assert } from './_private/assert.js';\nimport { quotaErrorCallbacks } from './models/quotaErrorCallbacks.js';\nimport './_version.js';\n/**\n * Adds a function to the set of quotaErrorCallbacks that will be executed if\n * there's a quota error.\n *\n * @param {Function} callback\n * @memberof workbox-core\n */\n// Can't change Function type\n// eslint-disable-next-line @typescript-eslint/ban-types\nfunction registerQuotaErrorCallback(callback) {\n    if (process.env.NODE_ENV !== 'production') {\n        assert.isType(callback, 'function', {\n            moduleName: 'workbox-core',\n            funcName: 'register',\n            paramName: 'callback',\n        });\n    }\n    quotaErrorCallbacks.add(callback);\n    if (process.env.NODE_ENV !== 'production') {\n        logger.log('Registered a callback to respond to quota errors.', callback);\n    }\n}\nexport { registerQuotaErrorCallback };\n", "const instanceOfAny = (object, constructors) => constructors.some((c) => object instanceof c);\n\nlet idbProxyableTypes;\nlet cursorAdvanceMethods;\n// This is a function to prevent it throwing up in node environments.\nfunction getIdbProxyableTypes() {\n    return (idbProxyableTypes ||\n        (idbProxyableTypes = [\n            IDBDatabase,\n            IDBObjectStore,\n            IDBIndex,\n            IDBCursor,\n            IDBTransaction,\n        ]));\n}\n// This is a function to prevent it throwing up in node environments.\nfunction getCursorAdvanceMethods() {\n    return (cursorAdvanceMethods ||\n        (cursorAdvanceMethods = [\n            IDBCursor.prototype.advance,\n            IDBCursor.prototype.continue,\n            IDBCursor.prototype.continuePrimaryKey,\n        ]));\n}\nconst cursorRequestMap = new WeakMap();\nconst transactionDoneMap = new WeakMap();\nconst transactionStoreNamesMap = new WeakMap();\nconst transformCache = new WeakMap();\nconst reverseTransformCache = new WeakMap();\nfunction promisifyRequest(request) {\n    const promise = new Promise((resolve, reject) => {\n        const unlisten = () => {\n            request.removeEventListener('success', success);\n            request.removeEventListener('error', error);\n        };\n        const success = () => {\n            resolve(wrap(request.result));\n            unlisten();\n        };\n        const error = () => {\n            reject(request.error);\n            unlisten();\n        };\n        request.addEventListener('success', success);\n        request.addEventListener('error', error);\n    });\n    promise\n        .then((value) => {\n        // Since cursoring reuses the IDBRequest (*sigh*), we cache it for later retrieval\n        // (see wrapFunction).\n        if (value instanceof IDBCursor) {\n            cursorRequestMap.set(value, request);\n        }\n        // Catching to avoid \"Uncaught Promise exceptions\"\n    })\n        .catch(() => { });\n    // This mapping exists in reverseTransformCache but doesn't doesn't exist in transformCache. This\n    // is because we create many promises from a single IDBRequest.\n    reverseTransformCache.set(promise, request);\n    return promise;\n}\nfunction cacheDonePromiseForTransaction(tx) {\n    // Early bail if we've already created a done promise for this transaction.\n    if (transactionDoneMap.has(tx))\n        return;\n    const done = new Promise((resolve, reject) => {\n        const unlisten = () => {\n            tx.removeEventListener('complete', complete);\n            tx.removeEventListener('error', error);\n            tx.removeEventListener('abort', error);\n        };\n        const complete = () => {\n            resolve();\n            unlisten();\n        };\n        const error = () => {\n            reject(tx.error || new DOMException('AbortError', 'AbortError'));\n            unlisten();\n        };\n        tx.addEventListener('complete', complete);\n        tx.addEventListener('error', error);\n        tx.addEventListener('abort', error);\n    });\n    // Cache it for later retrieval.\n    transactionDoneMap.set(tx, done);\n}\nlet idbProxyTraps = {\n    get(target, prop, receiver) {\n        if (target instanceof IDBTransaction) {\n            // Special handling for transaction.done.\n            if (prop === 'done')\n                return transactionDoneMap.get(target);\n            // Polyfill for objectStoreNames because of Edge.\n            if (prop === 'objectStoreNames') {\n                return target.objectStoreNames || transactionStoreNamesMap.get(target);\n            }\n            // Make tx.store return the only store in the transaction, or undefined if there are many.\n            if (prop === 'store') {\n                return receiver.objectStoreNames[1]\n                    ? undefined\n                    : receiver.objectStore(receiver.objectStoreNames[0]);\n            }\n        }\n        // Else transform whatever we get back.\n        return wrap(target[prop]);\n    },\n    set(target, prop, value) {\n        target[prop] = value;\n        return true;\n    },\n    has(target, prop) {\n        if (target instanceof IDBTransaction &&\n            (prop === 'done' || prop === 'store')) {\n            return true;\n        }\n        return prop in target;\n    },\n};\nfunction replaceTraps(callback) {\n    idbProxyTraps = callback(idbProxyTraps);\n}\nfunction wrapFunction(func) {\n    // Due to expected object equality (which is enforced by the caching in `wrap`), we\n    // only create one new func per func.\n    // Edge doesn't support objectStoreNames (booo), so we polyfill it here.\n    if (func === IDBDatabase.prototype.transaction &&\n        !('objectStoreNames' in IDBTransaction.prototype)) {\n        return function (storeNames, ...args) {\n            const tx = func.call(unwrap(this), storeNames, ...args);\n            transactionStoreNamesMap.set(tx, storeNames.sort ? storeNames.sort() : [storeNames]);\n            return wrap(tx);\n        };\n    }\n    // Cursor methods are special, as the behaviour is a little more different to standard IDB. In\n    // IDB, you advance the cursor and wait for a new 'success' on the IDBRequest that gave you the\n    // cursor. It's kinda like a promise that can resolve with many values. That doesn't make sense\n    // with real promises, so each advance methods returns a new promise for the cursor object, or\n    // undefined if the end of the cursor has been reached.\n    if (getCursorAdvanceMethods().includes(func)) {\n        return function (...args) {\n            // Calling the original function with the proxy as 'this' causes ILLEGAL INVOCATION, so we use\n            // the original object.\n            func.apply(unwrap(this), args);\n            return wrap(cursorRequestMap.get(this));\n        };\n    }\n    return function (...args) {\n        // Calling the original function with the proxy as 'this' causes ILLEGAL INVOCATION, so we use\n        // the original object.\n        return wrap(func.apply(unwrap(this), args));\n    };\n}\nfunction transformCachableValue(value) {\n    if (typeof value === 'function')\n        return wrapFunction(value);\n    // This doesn't return, it just creates a 'done' promise for the transaction,\n    // which is later returned for transaction.done (see idbObjectHandler).\n    if (value instanceof IDBTransaction)\n        cacheDonePromiseForTransaction(value);\n    if (instanceOfAny(value, getIdbProxyableTypes()))\n        return new Proxy(value, idbProxyTraps);\n    // Return the same value back if we're not going to transform it.\n    return value;\n}\nfunction wrap(value) {\n    // We sometimes generate multiple promises from a single IDBRequest (eg when cursoring), because\n    // IDB is weird and a single IDBRequest can yield many responses, so these can't be cached.\n    if (value instanceof IDBRequest)\n        return promisifyRequest(value);\n    // If we've already transformed this value before, reuse the transformed value.\n    // This is faster, but it also provides object equality.\n    if (transformCache.has(value))\n        return transformCache.get(value);\n    const newValue = transformCachableValue(value);\n    // Not all types are transformed.\n    // These may be primitive types, so they can't be WeakMap keys.\n    if (newValue !== value) {\n        transformCache.set(value, newValue);\n        reverseTransformCache.set(newValue, value);\n    }\n    return newValue;\n}\nconst unwrap = (value) => reverseTransformCache.get(value);\n\nexport { reverseTransformCache as a, instanceOfAny as i, replaceTraps as r, unwrap as u, wrap as w };\n", "import { w as wrap, r as replaceTraps } from './wrap-idb-value.js';\nexport { u as unwrap, w as wrap } from './wrap-idb-value.js';\n\n/**\n * Open a database.\n *\n * @param name Name of the database.\n * @param version Schema version.\n * @param callbacks Additional callbacks.\n */\nfunction openDB(name, version, { blocked, upgrade, blocking, terminated } = {}) {\n    const request = indexedDB.open(name, version);\n    const openPromise = wrap(request);\n    if (upgrade) {\n        request.addEventListener('upgradeneeded', (event) => {\n            upgrade(wrap(request.result), event.oldVersion, event.newVersion, wrap(request.transaction), event);\n        });\n    }\n    if (blocked) {\n        request.addEventListener('blocked', (event) => blocked(\n        // Casting due to https://github.com/microsoft/TypeScript-DOM-lib-generator/pull/1405\n        event.oldVersion, event.newVersion, event));\n    }\n    openPromise\n        .then((db) => {\n        if (terminated)\n            db.addEventListener('close', () => terminated());\n        if (blocking) {\n            db.addEventListener('versionchange', (event) => blocking(event.oldVersion, event.newVersion, event));\n        }\n    })\n        .catch(() => { });\n    return openPromise;\n}\n/**\n * Delete a database.\n *\n * @param name Name of the database.\n */\nfunction deleteDB(name, { blocked } = {}) {\n    const request = indexedDB.deleteDatabase(name);\n    if (blocked) {\n        request.addEventListener('blocked', (event) => blocked(\n        // Casting due to https://github.com/microsoft/TypeScript-DOM-lib-generator/pull/1405\n        event.oldVersion, event));\n    }\n    return wrap(request).then(() => undefined);\n}\n\nconst readMethods = ['get', 'getKey', 'getAll', 'getAllKeys', 'count'];\nconst writeMethods = ['put', 'add', 'delete', 'clear'];\nconst cachedMethods = new Map();\nfunction getMethod(target, prop) {\n    if (!(target instanceof IDBDatabase &&\n        !(prop in target) &&\n        typeof prop === 'string')) {\n        return;\n    }\n    if (cachedMethods.get(prop))\n        return cachedMethods.get(prop);\n    const targetFuncName = prop.replace(/FromIndex$/, '');\n    const useIndex = prop !== targetFuncName;\n    const isWrite = writeMethods.includes(targetFuncName);\n    if (\n    // Bail if the target doesn't exist on the target. Eg, getAll isn't in Edge.\n    !(targetFuncName in (useIndex ? IDBIndex : IDBObjectStore).prototype) ||\n        !(isWrite || readMethods.includes(targetFuncName))) {\n        return;\n    }\n    const method = async function (storeName, ...args) {\n        // isWrite ? 'readwrite' : undefined gzipps better, but fails in Edge :(\n        const tx = this.transaction(storeName, isWrite ? 'readwrite' : 'readonly');\n        let target = tx.store;\n        if (useIndex)\n            target = target.index(args.shift());\n        // Must reject if op rejects.\n        // If it's a write operation, must reject if tx.done rejects.\n        // Must reject with op rejection first.\n        // Must resolve with op value.\n        // Must handle both promises (no unhandled rejections)\n        return (await Promise.all([\n            target[targetFuncName](...args),\n            isWrite && tx.done,\n        ]))[0];\n    };\n    cachedMethods.set(prop, method);\n    return method;\n}\nreplaceTraps((oldTraps) => ({\n    ...oldTraps,\n    get: (target, prop, receiver) => getMethod(target, prop) || oldTraps.get(target, prop, receiver),\n    has: (target, prop) => !!getMethod(target, prop) || oldTraps.has(target, prop),\n}));\n\nexport { deleteDB, openDB };\n", "\"use strict\";\n// @ts-ignore\ntry {\n    self['workbox:expiration:6.5.4'] && _();\n}\ncatch (e) { }\n", "/*\n  Copyright 2018 Google LLC\n\n  Use of this source code is governed by an MIT-style\n  license that can be found in the LICENSE file or at\n  https://opensource.org/licenses/MIT.\n*/\nimport { openDB, deleteDB } from 'idb';\nimport '../_version.js';\nconst DB_NAME = 'workbox-expiration';\nconst CACHE_OBJECT_STORE = 'cache-entries';\nconst normalizeURL = (unNormalizedUrl) => {\n    const url = new URL(unNormalizedUrl, location.href);\n    url.hash = '';\n    return url.href;\n};\n/**\n * Returns the timestamp model.\n *\n * @private\n */\nclass CacheTimestampsModel {\n    /**\n     *\n     * @param {string} cacheName\n     *\n     * @private\n     */\n    constructor(cacheName) {\n        this._db = null;\n        this._cacheName = cacheName;\n    }\n    /**\n     * Performs an upgrade of indexedDB.\n     *\n     * @param {IDBPDatabase<CacheDbSchema>} db\n     *\n     * @private\n     */\n    _upgradeDb(db) {\n        // TODO(philipwalton): EdgeHTML doesn't support arrays as a keyPath, so we\n        // have to use the `id` keyPath here and create our own values (a\n        // concatenation of `url + cacheName`) instead of simply using\n        // `keyPath: ['url', 'cacheName']`, which is supported in other browsers.\n        const objStore = db.createObjectStore(CACHE_OBJECT_STORE, { keyPath: 'id' });\n        // TODO(philipwalton): once we don't have to support EdgeHTML, we can\n        // create a single index with the keyPath `['cacheName', 'timestamp']`\n        // instead of doing both these indexes.\n        objStore.createIndex('cacheName', 'cacheName', { unique: false });\n        objStore.createIndex('timestamp', 'timestamp', { unique: false });\n    }\n    /**\n     * Performs an upgrade of indexedDB and deletes deprecated DBs.\n     *\n     * @param {IDBPDatabase<CacheDbSchema>} db\n     *\n     * @private\n     */\n    _upgradeDbAndDeleteOldDbs(db) {\n        this._upgradeDb(db);\n        if (this._cacheName) {\n            void deleteDB(this._cacheName);\n        }\n    }\n    /**\n     * @param {string} url\n     * @param {number} timestamp\n     *\n     * @private\n     */\n    async setTimestamp(url, timestamp) {\n        url = normalizeURL(url);\n        const entry = {\n            url,\n            timestamp,\n            cacheName: this._cacheName,\n            // Creating an ID from the URL and cache name won't be necessary once\n            // Edge switches to Chromium and all browsers we support work with\n            // array keyPaths.\n            id: this._getId(url),\n        };\n        const db = await this.getDb();\n        const tx = db.transaction(CACHE_OBJECT_STORE, 'readwrite', {\n            durability: 'relaxed',\n        });\n        await tx.store.put(entry);\n        await tx.done;\n    }\n    /**\n     * Returns the timestamp stored for a given URL.\n     *\n     * @param {string} url\n     * @return {number | undefined}\n     *\n     * @private\n     */\n    async getTimestamp(url) {\n        const db = await this.getDb();\n        const entry = await db.get(CACHE_OBJECT_STORE, this._getId(url));\n        return entry === null || entry === void 0 ? void 0 : entry.timestamp;\n    }\n    /**\n     * Iterates through all the entries in the object store (from newest to\n     * oldest) and removes entries once either `maxCount` is reached or the\n     * entry's timestamp is less than `minTimestamp`.\n     *\n     * @param {number} minTimestamp\n     * @param {number} maxCount\n     * @return {Array<string>}\n     *\n     * @private\n     */\n    async expireEntries(minTimestamp, maxCount) {\n        const db = await this.getDb();\n        let cursor = await db\n            .transaction(CACHE_OBJECT_STORE)\n            .store.index('timestamp')\n            .openCursor(null, 'prev');\n        const entriesToDelete = [];\n        let entriesNotDeletedCount = 0;\n        while (cursor) {\n            const result = cursor.value;\n            // TODO(philipwalton): once we can use a multi-key index, we\n            // won't have to check `cacheName` here.\n            if (result.cacheName === this._cacheName) {\n                // Delete an entry if it's older than the max age or\n                // if we already have the max number allowed.\n                if ((minTimestamp && result.timestamp < minTimestamp) ||\n                    (maxCount && entriesNotDeletedCount >= maxCount)) {\n                    // TODO(philipwalton): we should be able to delete the\n                    // entry right here, but doing so causes an iteration\n                    // bug in Safari stable (fixed in TP). Instead we can\n                    // store the keys of the entries to delete, and then\n                    // delete the separate transactions.\n                    // https://github.com/GoogleChrome/workbox/issues/1978\n                    // cursor.delete();\n                    // We only need to return the URL, not the whole entry.\n                    entriesToDelete.push(cursor.value);\n                }\n                else {\n                    entriesNotDeletedCount++;\n                }\n            }\n            cursor = await cursor.continue();\n        }\n        // TODO(philipwalton): once the Safari bug in the following issue is fixed,\n        // we should be able to remove this loop and do the entry deletion in the\n        // cursor loop above:\n        // https://github.com/GoogleChrome/workbox/issues/1978\n        const urlsDeleted = [];\n        for (const entry of entriesToDelete) {\n            await db.delete(CACHE_OBJECT_STORE, entry.id);\n            urlsDeleted.push(entry.url);\n        }\n        return urlsDeleted;\n    }\n    /**\n     * Takes a URL and returns an ID that will be unique in the object store.\n     *\n     * @param {string} url\n     * @return {string}\n     *\n     * @private\n     */\n    _getId(url) {\n        // Creating an ID from the URL and cache name won't be necessary once\n        // Edge switches to Chromium and all browsers we support work with\n        // array keyPaths.\n        return this._cacheName + '|' + normalizeURL(url);\n    }\n    /**\n     * Returns an open connection to the database.\n     *\n     * @private\n     */\n    async getDb() {\n        if (!this._db) {\n            this._db = await openDB(DB_NAME, 1, {\n                upgrade: this._upgradeDbAndDeleteOldDbs.bind(this),\n            });\n        }\n        return this._db;\n    }\n}\nexport { CacheTimestampsModel };\n", "/*\n  Copyright 2018 Google LLC\n\n  Use of this source code is governed by an MIT-style\n  license that can be found in the LICENSE file or at\n  https://opensource.org/licenses/MIT.\n*/\nimport { assert } from 'workbox-core/_private/assert.js';\nimport { dontWaitFor } from 'workbox-core/_private/dontWaitFor.js';\nimport { logger } from 'workbox-core/_private/logger.js';\nimport { WorkboxError } from 'workbox-core/_private/WorkboxError.js';\nimport { CacheTimestampsModel } from './models/CacheTimestampsModel.js';\nimport './_version.js';\n/**\n * The `CacheExpiration` class allows you define an expiration and / or\n * limit on the number of responses stored in a\n * [`Cache`](https://developer.mozilla.org/en-US/docs/Web/API/Cache).\n *\n * @memberof workbox-expiration\n */\nclass CacheExpiration {\n    /**\n     * To construct a new CacheExpiration instance you must provide at least\n     * one of the `config` properties.\n     *\n     * @param {string} cacheName Name of the cache to apply restrictions to.\n     * @param {Object} config\n     * @param {number} [config.maxEntries] The maximum number of entries to cache.\n     * Entries used the least will be removed as the maximum is reached.\n     * @param {number} [config.maxAgeSeconds] The maximum age of an entry before\n     * it's treated as stale and removed.\n     * @param {Object} [config.matchOptions] The [`CacheQueryOptions`](https://developer.mozilla.org/en-US/docs/Web/API/Cache/delete#Parameters)\n     * that will be used when calling `delete()` on the cache.\n     */\n    constructor(cacheName, config = {}) {\n        this._isRunning = false;\n        this._rerunRequested = false;\n        if (process.env.NODE_ENV !== 'production') {\n            assert.isType(cacheName, 'string', {\n                moduleName: 'workbox-expiration',\n                className: 'CacheExpiration',\n                funcName: 'constructor',\n                paramName: 'cacheName',\n            });\n            if (!(config.maxEntries || config.maxAgeSeconds)) {\n                throw new WorkboxError('max-entries-or-age-required', {\n                    moduleName: 'workbox-expiration',\n                    className: 'CacheExpiration',\n                    funcName: 'constructor',\n                });\n            }\n            if (config.maxEntries) {\n                assert.isType(config.maxEntries, 'number', {\n                    moduleName: 'workbox-expiration',\n                    className: 'CacheExpiration',\n                    funcName: 'constructor',\n                    paramName: 'config.maxEntries',\n                });\n            }\n            if (config.maxAgeSeconds) {\n                assert.isType(config.maxAgeSeconds, 'number', {\n                    moduleName: 'workbox-expiration',\n                    className: 'CacheExpiration',\n                    funcName: 'constructor',\n                    paramName: 'config.maxAgeSeconds',\n                });\n            }\n        }\n        this._maxEntries = config.maxEntries;\n        this._maxAgeSeconds = config.maxAgeSeconds;\n        this._matchOptions = config.matchOptions;\n        this._cacheName = cacheName;\n        this._timestampModel = new CacheTimestampsModel(cacheName);\n    }\n    /**\n     * Expires entries for the given cache and given criteria.\n     */\n    async expireEntries() {\n        if (this._isRunning) {\n            this._rerunRequested = true;\n            return;\n        }\n        this._isRunning = true;\n        const minTimestamp = this._maxAgeSeconds\n            ? Date.now() - this._maxAgeSeconds * 1000\n            : 0;\n        const urlsExpired = await this._timestampModel.expireEntries(minTimestamp, this._maxEntries);\n        // Delete URLs from the cache\n        const cache = await self.caches.open(this._cacheName);\n        for (const url of urlsExpired) {\n            await cache.delete(url, this._matchOptions);\n        }\n        if (process.env.NODE_ENV !== 'production') {\n            if (urlsExpired.length > 0) {\n                logger.groupCollapsed(`Expired ${urlsExpired.length} ` +\n                    `${urlsExpired.length === 1 ? 'entry' : 'entries'} and removed ` +\n                    `${urlsExpired.length === 1 ? 'it' : 'them'} from the ` +\n                    `'${this._cacheName}' cache.`);\n                logger.log(`Expired the following ${urlsExpired.length === 1 ? 'URL' : 'URLs'}:`);\n                urlsExpired.forEach((url) => logger.log(`    ${url}`));\n                logger.groupEnd();\n            }\n            else {\n                logger.debug(`Cache expiration ran and found no entries to remove.`);\n            }\n        }\n        this._isRunning = false;\n        if (this._rerunRequested) {\n            this._rerunRequested = false;\n            dontWaitFor(this.expireEntries());\n        }\n    }\n    /**\n     * Update the timestamp for the given URL. This ensures the when\n     * removing entries based on maximum entries, most recently used\n     * is accurate or when expiring, the timestamp is up-to-date.\n     *\n     * @param {string} url\n     */\n    async updateTimestamp(url) {\n        if (process.env.NODE_ENV !== 'production') {\n            assert.isType(url, 'string', {\n                moduleName: 'workbox-expiration',\n                className: 'CacheExpiration',\n                funcName: 'updateTimestamp',\n                paramName: 'url',\n            });\n        }\n        await this._timestampModel.setTimestamp(url, Date.now());\n    }\n    /**\n     * Can be used to check if a URL has expired or not before it's used.\n     *\n     * This requires a look up from IndexedDB, so can be slow.\n     *\n     * Note: This method will not remove the cached entry, call\n     * `expireEntries()` to remove indexedDB and Cache entries.\n     *\n     * @param {string} url\n     * @return {boolean}\n     */\n    async isURLExpired(url) {\n        if (!this._maxAgeSeconds) {\n            if (process.env.NODE_ENV !== 'production') {\n                throw new WorkboxError(`expired-test-without-max-age`, {\n                    methodName: 'isURLExpired',\n                    paramName: 'maxAgeSeconds',\n                });\n            }\n            return false;\n        }\n        else {\n            const timestamp = await this._timestampModel.getTimestamp(url);\n            const expireOlderThan = Date.now() - this._maxAgeSeconds * 1000;\n            return timestamp !== undefined ? timestamp < expireOlderThan : true;\n        }\n    }\n    /**\n     * Removes the IndexedDB object store used to keep track of cache expiration\n     * metadata.\n     */\n    async delete() {\n        // Make sure we don't attempt another rerun if we're called in the middle of\n        // a cache expiration.\n        this._rerunRequested = false;\n        await this._timestampModel.expireEntries(Infinity); // Expires all.\n    }\n}\nexport { CacheExpiration };\n", "/*\n  Copyright 2018 Google LLC\n\n  Use of this source code is governed by an MIT-style\n  license that can be found in the LICENSE file or at\n  https://opensource.org/licenses/MIT.\n*/\nimport { assert } from 'workbox-core/_private/assert.js';\nimport { cacheNames } from 'workbox-core/_private/cacheNames.js';\nimport { dontWaitFor } from 'workbox-core/_private/dontWaitFor.js';\nimport { getFriendlyURL } from 'workbox-core/_private/getFriendlyURL.js';\nimport { logger } from 'workbox-core/_private/logger.js';\nimport { registerQuotaErrorCallback } from 'workbox-core/registerQuotaErrorCallback.js';\nimport { WorkboxError } from 'workbox-core/_private/WorkboxError.js';\nimport { CacheExpiration } from './CacheExpiration.js';\nimport './_version.js';\n/**\n * This plugin can be used in a `workbox-strategy` to regularly enforce a\n * limit on the age and / or the number of cached requests.\n *\n * It can only be used with `workbox-strategy` instances that have a\n * [custom `cacheName` property set](/web/tools/workbox/guides/configure-workbox#custom_cache_names_in_strategies).\n * In other words, it can't be used to expire entries in strategy that uses the\n * default runtime cache name.\n *\n * Whenever a cached response is used or updated, this plugin will look\n * at the associated cache and remove any old or extra responses.\n *\n * When using `maxAgeSeconds`, responses may be used *once* after expiring\n * because the expiration clean up will not have occurred until *after* the\n * cached response has been used. If the response has a \"Date\" header, then\n * a light weight expiration check is performed and the response will not be\n * used immediately.\n *\n * When using `maxEntries`, the entry least-recently requested will be removed\n * from the cache first.\n *\n * @memberof workbox-expiration\n */\nclass ExpirationPlugin {\n    /**\n     * @param {ExpirationPluginOptions} config\n     * @param {number} [config.maxEntries] The maximum number of entries to cache.\n     * Entries used the least will be removed as the maximum is reached.\n     * @param {number} [config.maxAgeSeconds] The maximum age of an entry before\n     * it's treated as stale and removed.\n     * @param {Object} [config.matchOptions] The [`CacheQueryOptions`](https://developer.mozilla.org/en-US/docs/Web/API/Cache/delete#Parameters)\n     * that will be used when calling `delete()` on the cache.\n     * @param {boolean} [config.purgeOnQuotaError] Whether to opt this cache in to\n     * automatic deletion if the available storage quota has been exceeded.\n     */\n    constructor(config = {}) {\n        /**\n         * A \"lifecycle\" callback that will be triggered automatically by the\n         * `workbox-strategies` handlers when a `Response` is about to be returned\n         * from a [Cache](https://developer.mozilla.org/en-US/docs/Web/API/Cache) to\n         * the handler. It allows the `Response` to be inspected for freshness and\n         * prevents it from being used if the `Response`'s `Date` header value is\n         * older than the configured `maxAgeSeconds`.\n         *\n         * @param {Object} options\n         * @param {string} options.cacheName Name of the cache the response is in.\n         * @param {Response} options.cachedResponse The `Response` object that's been\n         *     read from a cache and whose freshness should be checked.\n         * @return {Response} Either the `cachedResponse`, if it's\n         *     fresh, or `null` if the `Response` is older than `maxAgeSeconds`.\n         *\n         * @private\n         */\n        this.cachedResponseWillBeUsed = async ({ event, request, cacheName, cachedResponse, }) => {\n            if (!cachedResponse) {\n                return null;\n            }\n            const isFresh = this._isResponseDateFresh(cachedResponse);\n            // Expire entries to ensure that even if the expiration date has\n            // expired, it'll only be used once.\n            const cacheExpiration = this._getCacheExpiration(cacheName);\n            dontWaitFor(cacheExpiration.expireEntries());\n            // Update the metadata for the request URL to the current timestamp,\n            // but don't `await` it as we don't want to block the response.\n            const updateTimestampDone = cacheExpiration.updateTimestamp(request.url);\n            if (event) {\n                try {\n                    event.waitUntil(updateTimestampDone);\n                }\n                catch (error) {\n                    if (process.env.NODE_ENV !== 'production') {\n                        // The event may not be a fetch event; only log the URL if it is.\n                        if ('request' in event) {\n                            logger.warn(`Unable to ensure service worker stays alive when ` +\n                                `updating cache entry for ` +\n                                `'${getFriendlyURL(event.request.url)}'.`);\n                        }\n                    }\n                }\n            }\n            return isFresh ? cachedResponse : null;\n        };\n        /**\n         * A \"lifecycle\" callback that will be triggered automatically by the\n         * `workbox-strategies` handlers when an entry is added to a cache.\n         *\n         * @param {Object} options\n         * @param {string} options.cacheName Name of the cache that was updated.\n         * @param {string} options.request The Request for the cached entry.\n         *\n         * @private\n         */\n        this.cacheDidUpdate = async ({ cacheName, request, }) => {\n            if (process.env.NODE_ENV !== 'production') {\n                assert.isType(cacheName, 'string', {\n                    moduleName: 'workbox-expiration',\n                    className: 'Plugin',\n                    funcName: 'cacheDidUpdate',\n                    paramName: 'cacheName',\n                });\n                assert.isInstance(request, Request, {\n                    moduleName: 'workbox-expiration',\n                    className: 'Plugin',\n                    funcName: 'cacheDidUpdate',\n                    paramName: 'request',\n                });\n            }\n            const cacheExpiration = this._getCacheExpiration(cacheName);\n            await cacheExpiration.updateTimestamp(request.url);\n            await cacheExpiration.expireEntries();\n        };\n        if (process.env.NODE_ENV !== 'production') {\n            if (!(config.maxEntries || config.maxAgeSeconds)) {\n                throw new WorkboxError('max-entries-or-age-required', {\n                    moduleName: 'workbox-expiration',\n                    className: 'Plugin',\n                    funcName: 'constructor',\n                });\n            }\n            if (config.maxEntries) {\n                assert.isType(config.maxEntries, 'number', {\n                    moduleName: 'workbox-expiration',\n                    className: 'Plugin',\n                    funcName: 'constructor',\n                    paramName: 'config.maxEntries',\n                });\n            }\n            if (config.maxAgeSeconds) {\n                assert.isType(config.maxAgeSeconds, 'number', {\n                    moduleName: 'workbox-expiration',\n                    className: 'Plugin',\n                    funcName: 'constructor',\n                    paramName: 'config.maxAgeSeconds',\n                });\n            }\n        }\n        this._config = config;\n        this._maxAgeSeconds = config.maxAgeSeconds;\n        this._cacheExpirations = new Map();\n        if (config.purgeOnQuotaError) {\n            registerQuotaErrorCallback(() => this.deleteCacheAndMetadata());\n        }\n    }\n    /**\n     * A simple helper method to return a CacheExpiration instance for a given\n     * cache name.\n     *\n     * @param {string} cacheName\n     * @return {CacheExpiration}\n     *\n     * @private\n     */\n    _getCacheExpiration(cacheName) {\n        if (cacheName === cacheNames.getRuntimeName()) {\n            throw new WorkboxError('expire-custom-caches-only');\n        }\n        let cacheExpiration = this._cacheExpirations.get(cacheName);\n        if (!cacheExpiration) {\n            cacheExpiration = new CacheExpiration(cacheName, this._config);\n            this._cacheExpirations.set(cacheName, cacheExpiration);\n        }\n        return cacheExpiration;\n    }\n    /**\n     * @param {Response} cachedResponse\n     * @return {boolean}\n     *\n     * @private\n     */\n    _isResponseDateFresh(cachedResponse) {\n        if (!this._maxAgeSeconds) {\n            // We aren't expiring by age, so return true, it's fresh\n            return true;\n        }\n        // Check if the 'date' header will suffice a quick expiration check.\n        // See https://github.com/GoogleChromeLabs/sw-toolbox/issues/164 for\n        // discussion.\n        const dateHeaderTimestamp = this._getDateHeaderTimestamp(cachedResponse);\n        if (dateHeaderTimestamp === null) {\n            // Unable to parse date, so assume it's fresh.\n            return true;\n        }\n        // If we have a valid headerTime, then our response is fresh iff the\n        // headerTime plus maxAgeSeconds is greater than the current time.\n        const now = Date.now();\n        return dateHeaderTimestamp >= now - this._maxAgeSeconds * 1000;\n    }\n    /**\n     * This method will extract the data header and parse it into a useful\n     * value.\n     *\n     * @param {Response} cachedResponse\n     * @return {number|null}\n     *\n     * @private\n     */\n    _getDateHeaderTimestamp(cachedResponse) {\n        if (!cachedResponse.headers.has('date')) {\n            return null;\n        }\n        const dateHeader = cachedResponse.headers.get('date');\n        const parsedDate = new Date(dateHeader);\n        const headerTime = parsedDate.getTime();\n        // If the Date header was invalid for some reason, parsedDate.getTime()\n        // will return NaN.\n        if (isNaN(headerTime)) {\n            return null;\n        }\n        return headerTime;\n    }\n    /**\n     * This is a helper method that performs two operations:\n     *\n     * - Deletes *all* the underlying Cache instances associated with this plugin\n     * instance, by calling caches.delete() on your behalf.\n     * - Deletes the metadata from IndexedDB used to keep track of expiration\n     * details for each Cache instance.\n     *\n     * When using cache expiration, calling this method is preferable to calling\n     * `caches.delete()` directly, since this will ensure that the IndexedDB\n     * metadata is also cleanly removed and open IndexedDB instances are deleted.\n     *\n     * Note that if you're *not* using cache expiration for a given cache, calling\n     * `caches.delete()` and passing in the cache's name should be sufficient.\n     * There is no Workbox-specific method needed for cleanup in that case.\n     */\n    async deleteCacheAndMetadata() {\n        // Do this one at a time instead of all at once via `Promise.all()` to\n        // reduce the chance of inconsistency if a promise rejects.\n        for (const [cacheName, cacheExpiration] of this._cacheExpirations) {\n            await self.caches.delete(cacheName);\n            await cacheExpiration.delete();\n        }\n        // Reset this._cacheExpirations to its initial state.\n        this._cacheExpirations = new Map();\n    }\n}\nexport { ExpirationPlugin };\n", "\"use strict\";\n// @ts-ignore\ntry {\n    self['workbox:recipes:6.5.4'] && _();\n}\ncatch (e) { }\n", "/*\n  Copyright 2020 Google LLC\n\n  Use of this source code is governed by an MIT-style\n  license that can be found in the LICENSE file or at\n  https://opensource.org/licenses/MIT.\n*/\nimport { registerRoute } from 'workbox-routing/registerRoute.js';\nimport { StaleWhileRevalidate } from 'workbox-strategies/StaleWhileRevalidate.js';\nimport { CacheFirst } from 'workbox-strategies/CacheFirst.js';\nimport { CacheableResponsePlugin } from 'workbox-cacheable-response/CacheableResponsePlugin.js';\nimport { ExpirationPlugin } from 'workbox-expiration/ExpirationPlugin.js';\nimport './_version.js';\n/**\n * An implementation of the [Google fonts]{@link https://developers.google.com/web/tools/workbox/guides/common-recipes#google_fonts} caching recipe\n *\n * @memberof workbox-recipes\n *\n * @param {Object} [options]\n * @param {string} [options.cachePrefix] Cache prefix for caching stylesheets and webfonts. Defaults to google-fonts\n * @param {number} [options.maxAgeSeconds] Maximum age, in seconds, that font entries will be cached for. Defaults to 1 year\n * @param {number} [options.maxEntries] Maximum number of fonts that will be cached. Defaults to 30\n */\nfunction googleFontsCache(options = {}) {\n    const sheetCacheName = `${options.cachePrefix || 'google-fonts'}-stylesheets`;\n    const fontCacheName = `${options.cachePrefix || 'google-fonts'}-webfonts`;\n    const maxAgeSeconds = options.maxAgeSeconds || 60 * 60 * 24 * 365;\n    const maxEntries = options.maxEntries || 30;\n    // Cache the Google Fonts stylesheets with a stale-while-revalidate strategy.\n    registerRoute(({ url }) => url.origin === 'https://fonts.googleapis.com', new StaleWhileRevalidate({\n        cacheName: sheetCacheName,\n    }));\n    // Cache the underlying font files with a cache-first strategy for 1 year.\n    registerRoute(({ url }) => url.origin === 'https://fonts.gstatic.com', new CacheFirst({\n        cacheName: fontCacheName,\n        plugins: [\n            new CacheableResponsePlugin({\n                statuses: [0, 200],\n            }),\n            new ExpirationPlugin({\n                maxAgeSeconds,\n                maxEntries,\n            }),\n        ],\n    }));\n}\nexport { googleFontsCache };\n", "import './_version.js';\n/**\n * @memberof workbox-recipes\n \n * @param {Object} options\n * @param {string[]} options.urls Paths to warm the strategy's cache with\n * @param {Strategy} options.strategy Strategy to use\n */\nfunction warmStrategyCache(options) {\n    self.addEventListener('install', (event) => {\n        const done = options.urls.map((path) => options.strategy.handleAll({\n            event,\n            request: new Request(path),\n        })[1]);\n        event.waitUntil(Promise.all(done));\n    });\n}\nexport { warmStrategyCache };\n", "/*\n  Copyright 2020 Google LLC\n\n  Use of this source code is governed by an MIT-style\n  license that can be found in the LICENSE file or at\n  https://opensource.org/licenses/MIT.\n*/\nimport { warmStrategyCache } from './warmStrategyCache';\nimport { registerRoute } from 'workbox-routing/registerRoute.js';\nimport { CacheFirst } from 'workbox-strategies/CacheFirst.js';\nimport { CacheableResponsePlugin } from 'workbox-cacheable-response/CacheableResponsePlugin.js';\nimport { ExpirationPlugin } from 'workbox-expiration/ExpirationPlugin.js';\nimport './_version.js';\n/**\n * An implementation of the [image caching recipe]{@link https://developers.google.com/web/tools/workbox/guides/common-recipes#caching_images}\n *\n * @memberof workbox-recipes\n *\n * @param {Object} [options]\n * @param {string} [options.cacheName] Name for cache. Defaults to images\n * @param {RouteMatchCallback} [options.matchCallback] Workbox callback function to call to match to. Defaults to request.destination === 'image';\n * @param {number} [options.maxAgeSeconds] Maximum age, in seconds, that font entries will be cached for. Defaults to 30 days\n * @param {number} [options.maxEntries] Maximum number of images that will be cached. Defaults to 60\n * @param {WorkboxPlugin[]} [options.plugins] Additional plugins to use for this recipe\n * @param {string[]} [options.warmCache] Paths to call to use to warm this cache\n */\nfunction imageCache(options = {}) {\n    const defaultMatchCallback = ({ request }) => request.destination === 'image';\n    const cacheName = options.cacheName || 'images';\n    const matchCallback = options.matchCallback || defaultMatchCallback;\n    const maxAgeSeconds = options.maxAgeSeconds || 30 * 24 * 60 * 60;\n    const maxEntries = options.maxEntries || 60;\n    const plugins = options.plugins || [];\n    plugins.push(new CacheableResponsePlugin({\n        statuses: [0, 200],\n    }));\n    plugins.push(new ExpirationPlugin({\n        maxEntries,\n        maxAgeSeconds,\n    }));\n    const strategy = new CacheFirst({\n        cacheName,\n        plugins,\n    });\n    registerRoute(matchCallback, strategy);\n    // Warms the cache\n    if (options.warmCache) {\n        warmStrategyCache({ urls: options.warmCache, strategy });\n    }\n}\nexport { imageCache };\n", "/*\n  Copyright 2020 Google LLC\n\n  Use of this source code is governed by an MIT-style\n  license that can be found in the LICENSE file or at\n  https://opensource.org/licenses/MIT.\n*/\nimport { warmStrategyCache } from './warmStrategyCache';\nimport { registerRoute } from 'workbox-routing/registerRoute.js';\nimport { StaleWhileRevalidate } from 'workbox-strategies/StaleWhileRevalidate.js';\nimport { CacheableResponsePlugin } from 'workbox-cacheable-response/CacheableResponsePlugin.js';\nimport './_version.js';\n/**\n * An implementation of the [CSS and JavaScript files recipe]{@link https://developers.google.com/web/tools/workbox/guides/common-recipes#cache_css_and_javascript_files}\n *\n * @memberof workbox-recipes\n *\n * @param {Object} [options]\n * @param {string} [options.cacheName] Name for cache. Defaults to static-resources\n * @param {RouteMatchCallback} [options.matchCallback] Workbox callback function to call to match to. Defaults to request.destination === 'style' || request.destination === 'script' || request.destination === 'worker';\n * @param {WorkboxPlugin[]} [options.plugins] Additional plugins to use for this recipe\n * @param {string[]} [options.warmCache] Paths to call to use to warm this cache\n */\nfunction staticResourceCache(options = {}) {\n    const defaultMatchCallback = ({ request }) => request.destination === 'style' ||\n        request.destination === 'script' ||\n        request.destination === 'worker';\n    const cacheName = options.cacheName || 'static-resources';\n    const matchCallback = options.matchCallback || defaultMatchCallback;\n    const plugins = options.plugins || [];\n    plugins.push(new CacheableResponsePlugin({\n        statuses: [0, 200],\n    }));\n    const strategy = new StaleWhileRevalidate({\n        cacheName,\n        plugins,\n    });\n    registerRoute(matchCallback, strategy);\n    // Warms the cache\n    if (options.warmCache) {\n        warmStrategyCache({ urls: options.warmCache, strategy });\n    }\n}\nexport { staticResourceCache };\n", "/*\n  Copyright 2020 Google LLC\n\n  Use of this source code is governed by an MIT-style\n  license that can be found in the LICENSE file or at\n  https://opensource.org/licenses/MIT.\n*/\nimport { warmStrategyCache } from './warmStrategyCache';\nimport { registerRoute } from 'workbox-routing/registerRoute.js';\nimport { NetworkFirst } from 'workbox-strategies/NetworkFirst.js';\nimport { CacheableResponsePlugin } from 'workbox-cacheable-response/CacheableResponsePlugin.js';\nimport './_version.js';\n/**\n * An implementation of a page caching recipe with a network timeout\n *\n * @memberof workbox-recipes\n *\n * @param {Object} [options]\n * @param {string} [options.cacheName] Name for cache. Defaults to pages\n * @param {RouteMatchCallback} [options.matchCallback] Workbox callback function to call to match to. Defaults to request.mode === 'navigate';\n * @param {number} [options.networkTimoutSeconds] Maximum amount of time, in seconds, to wait on the network before falling back to cache. Defaults to 3\n * @param {WorkboxPlugin[]} [options.plugins] Additional plugins to use for this recipe\n * @param {string[]} [options.warmCache] Paths to call to use to warm this cache\n */\nfunction pageCache(options = {}) {\n    const defaultMatchCallback = ({ request }) => request.mode === 'navigate';\n    const cacheName = options.cacheName || 'pages';\n    const matchCallback = options.matchCallback || defaultMatchCallback;\n    const networkTimeoutSeconds = options.networkTimeoutSeconds || 3;\n    const plugins = options.plugins || [];\n    plugins.push(new CacheableResponsePlugin({\n        statuses: [0, 200],\n    }));\n    const strategy = new NetworkFirst({\n        networkTimeoutSeconds,\n        cacheName,\n        plugins,\n    });\n    // Registers the route\n    registerRoute(matchCallback, strategy);\n    // Warms the cache\n    if (options.warmCache) {\n        warmStrategyCache({ urls: options.warmCache, strategy });\n    }\n}\nexport { pageCache };\n", "/*\n  Copyright 2020 Google LLC\n  Use of this source code is governed by an MIT-style\n  license that can be found in the LICENSE file or at\n  https://opensource.org/licenses/MIT.\n*/\nimport '../_version.js';\n/**\n * A utility method that makes it easier to use `event.waitUntil` with\n * async functions and return the result.\n *\n * @param {ExtendableEvent} event\n * @param {Function} asyncFn\n * @return {Function}\n * @private\n */\nfunction waitUntil(event, asyncFn) {\n    const returnPromise = asyncFn();\n    event.waitUntil(returnPromise);\n    return returnPromise;\n}\nexport { waitUntil };\n", "\"use strict\";\n// @ts-ignore\ntry {\n    self['workbox:precaching:6.5.4'] && _();\n}\ncatch (e) { }\n", "/*\n  Copyright 2018 Google LLC\n\n  Use of this source code is governed by an MIT-style\n  license that can be found in the LICENSE file or at\n  https://opensource.org/licenses/MIT.\n*/\nimport { WorkboxError } from 'workbox-core/_private/WorkboxError.js';\nimport '../_version.js';\n// Name of the search parameter used to store revision info.\nconst REVISION_SEARCH_PARAM = '__WB_REVISION__';\n/**\n * Converts a manifest entry into a versioned URL suitable for precaching.\n *\n * @param {Object|string} entry\n * @return {string} A URL with versioning info.\n *\n * @private\n * @memberof workbox-precaching\n */\nexport function createCacheKey(entry) {\n    if (!entry) {\n        throw new WorkboxError('add-to-cache-list-unexpected-type', { entry });\n    }\n    // If a precache manifest entry is a string, it's assumed to be a versioned\n    // URL, like '/app.abcd1234.js'. Return as-is.\n    if (typeof entry === 'string') {\n        const urlObject = new URL(entry, location.href);\n        return {\n            cacheKey: urlObject.href,\n            url: urlObject.href,\n        };\n    }\n    const { revision, url } = entry;\n    if (!url) {\n        throw new WorkboxError('add-to-cache-list-unexpected-type', { entry });\n    }\n    // If there's just a URL and no revision, then it's also assumed to be a\n    // versioned URL.\n    if (!revision) {\n        const urlObject = new URL(url, location.href);\n        return {\n            cacheKey: urlObject.href,\n            url: urlObject.href,\n        };\n    }\n    // Otherwise, construct a properly versioned URL using the custom Workbox\n    // search parameter along with the revision info.\n    const cacheKeyURL = new URL(url, location.href);\n    const originalURL = new URL(url, location.href);\n    cacheKeyURL.searchParams.set(REVISION_SEARCH_PARAM, revision);\n    return {\n        cacheKey: cacheKeyURL.href,\n        url: originalURL.href,\n    };\n}\n", "/*\n  Copyright 2020 Google LLC\n\n  Use of this source code is governed by an MIT-style\n  license that can be found in the LICENSE file or at\n  https://opensource.org/licenses/MIT.\n*/\nimport '../_version.js';\n/**\n * A plugin, designed to be used with PrecacheController, to determine the\n * of assets that were updated (or not updated) during the install event.\n *\n * @private\n */\nclass PrecacheInstallReportPlugin {\n    constructor() {\n        this.updatedURLs = [];\n        this.notUpdatedURLs = [];\n        this.handlerWillStart = async ({ request, state, }) => {\n            // TODO: `state` should never be undefined...\n            if (state) {\n                state.originalRequest = request;\n            }\n        };\n        this.cachedResponseWillBeUsed = async ({ event, state, cachedResponse, }) => {\n            if (event.type === 'install') {\n                if (state &&\n                    state.originalRequest &&\n                    state.originalRequest instanceof Request) {\n                    // TODO: `state` should never be undefined...\n                    const url = state.originalRequest.url;\n                    if (cachedResponse) {\n                        this.notUpdatedURLs.push(url);\n                    }\n                    else {\n                        this.updatedURLs.push(url);\n                    }\n                }\n            }\n            return cachedResponse;\n        };\n    }\n}\nexport { PrecacheInstallReportPlugin };\n", "/*\n  Copyright 2020 Google LLC\n\n  Use of this source code is governed by an MIT-style\n  license that can be found in the LICENSE file or at\n  https://opensource.org/licenses/MIT.\n*/\nimport '../_version.js';\n/**\n * A plugin, designed to be used with PrecacheController, to translate URLs into\n * the corresponding cache key, based on the current revision info.\n *\n * @private\n */\nclass PrecacheCacheKeyPlugin {\n    constructor({ precacheController }) {\n        this.cacheKeyWillBeUsed = async ({ request, params, }) => {\n            // Params is type any, can't change right now.\n            /* eslint-disable */\n            const cacheKey = (params === null || params === void 0 ? void 0 : params.cacheKey) ||\n                this._precacheController.getCacheKeyForURL(request.url);\n            /* eslint-enable */\n            return cacheKey\n                ? new Request(cacheKey, { headers: request.headers })\n                : request;\n        };\n        this._precacheController = precacheController;\n    }\n}\nexport { PrecacheCacheKeyPlugin };\n", "/*\n  Copyright 2018 Google LLC\n\n  Use of this source code is governed by an MIT-style\n  license that can be found in the LICENSE file or at\n  https://opensource.org/licenses/MIT.\n*/\nimport { logger } from 'workbox-core/_private/logger.js';\nimport '../_version.js';\n/**\n * @param {string} groupTitle\n * @param {Array<string>} deletedURLs\n *\n * @private\n */\nconst logGroup = (groupTitle, deletedURLs) => {\n    logger.groupCollapsed(groupTitle);\n    for (const url of deletedURLs) {\n        logger.log(url);\n    }\n    logger.groupEnd();\n};\n/**\n * @param {Array<string>} deletedURLs\n *\n * @private\n * @memberof workbox-precaching\n */\nexport function printCleanupDetails(deletedURLs) {\n    const deletionCount = deletedURLs.length;\n    if (deletionCount > 0) {\n        logger.groupCollapsed(`During precaching cleanup, ` +\n            `${deletionCount} cached ` +\n            `request${deletionCount === 1 ? ' was' : 's were'} deleted.`);\n        logGroup('Deleted Cache Requests', deletedURLs);\n        logger.groupEnd();\n    }\n}\n", "/*\n  Copyright 2018 Google LLC\n\n  Use of this source code is governed by an MIT-style\n  license that can be found in the LICENSE file or at\n  https://opensource.org/licenses/MIT.\n*/\nimport { logger } from 'workbox-core/_private/logger.js';\nimport '../_version.js';\n/**\n * @param {string} groupTitle\n * @param {Array<string>} urls\n *\n * @private\n */\nfunction _nestedGroup(groupTitle, urls) {\n    if (urls.length === 0) {\n        return;\n    }\n    logger.groupCollapsed(groupTitle);\n    for (const url of urls) {\n        logger.log(url);\n    }\n    logger.groupEnd();\n}\n/**\n * @param {Array<string>} urlsToPrecache\n * @param {Array<string>} urlsAlreadyPrecached\n *\n * @private\n * @memberof workbox-precaching\n */\nexport function printInstallDetails(urlsToPrecache, urlsAlreadyPrecached) {\n    const precachedCount = urlsToPrecache.length;\n    const alreadyPrecachedCount = urlsAlreadyPrecached.length;\n    if (precachedCount || alreadyPrecachedCount) {\n        let message = `Precaching ${precachedCount} file${precachedCount === 1 ? '' : 's'}.`;\n        if (alreadyPrecachedCount > 0) {\n            message +=\n                ` ${alreadyPrecachedCount} ` +\n                    `file${alreadyPrecachedCount === 1 ? ' is' : 's are'} already cached.`;\n        }\n        logger.groupCollapsed(message);\n        _nestedGroup(`View newly precached URLs.`, urlsToPrecache);\n        _nestedGroup(`View previously precached URLs.`, urlsAlreadyPrecached);\n        logger.groupEnd();\n    }\n}\n", "/*\n  Copyright 2019 Google LLC\n\n  Use of this source code is governed by an MIT-style\n  license that can be found in the LICENSE file or at\n  https://opensource.org/licenses/MIT.\n*/\nimport '../_version.js';\nlet supportStatus;\n/**\n * A utility function that determines whether the current browser supports\n * constructing a new `Response` from a `response.body` stream.\n *\n * @return {boolean} `true`, if the current browser can successfully\n *     construct a `Response` from a `response.body` stream, `false` otherwise.\n *\n * @private\n */\nfunction canConstructResponseFromBodyStream() {\n    if (supportStatus === undefined) {\n        const testResponse = new Response('');\n        if ('body' in testResponse) {\n            try {\n                new Response(testResponse.body);\n                supportStatus = true;\n            }\n            catch (error) {\n                supportStatus = false;\n            }\n        }\n        supportStatus = false;\n    }\n    return supportStatus;\n}\nexport { canConstructResponseFromBodyStream };\n", "/*\n  Copyright 2019 Google LLC\n\n  Use of this source code is governed by an MIT-style\n  license that can be found in the LICENSE file or at\n  https://opensource.org/licenses/MIT.\n*/\nimport { canConstructResponseFromBodyStream } from './_private/canConstructResponseFromBodyStream.js';\nimport { WorkboxError } from './_private/WorkboxError.js';\nimport './_version.js';\n/**\n * Allows developers to copy a response and modify its `headers`, `status`,\n * or `statusText` values (the values settable via a\n * [`ResponseInit`]{@link https://developer.mozilla.org/en-US/docs/Web/API/Response/Response#Syntax}\n * object in the constructor).\n * To modify these values, pass a function as the second argument. That\n * function will be invoked with a single object with the response properties\n * `{headers, status, statusText}`. The return value of this function will\n * be used as the `ResponseInit` for the new `Response`. To change the values\n * either modify the passed parameter(s) and return it, or return a totally\n * new object.\n *\n * This method is intentionally limited to same-origin responses, regardless of\n * whether CORS was used or not.\n *\n * @param {Response} response\n * @param {Function} modifier\n * @memberof workbox-core\n */\nasync function copyResponse(response, modifier) {\n    let origin = null;\n    // If response.url isn't set, assume it's cross-origin and keep origin null.\n    if (response.url) {\n        const responseURL = new URL(response.url);\n        origin = responseURL.origin;\n    }\n    if (origin !== self.location.origin) {\n        throw new WorkboxError('cross-origin-copy-response', { origin });\n    }\n    const clonedResponse = response.clone();\n    // Create a fresh `ResponseInit` object by cloning the headers.\n    const responseInit = {\n        headers: new Headers(clonedResponse.headers),\n        status: clonedResponse.status,\n        statusText: clonedResponse.statusText,\n    };\n    // Apply any user modifications.\n    const modifiedResponseInit = modifier ? modifier(responseInit) : responseInit;\n    // Create the new response from the body stream and `ResponseInit`\n    // modifications. Note: not all browsers support the Response.body stream,\n    // so fall back to reading the entire body into memory as a blob.\n    const body = canConstructResponseFromBodyStream()\n        ? clonedResponse.body\n        : await clonedResponse.blob();\n    return new Response(body, modifiedResponseInit);\n}\nexport { copyResponse };\n", "/*\n  Copyright 2020 Google LLC\n\n  Use of this source code is governed by an MIT-style\n  license that can be found in the LICENSE file or at\n  https://opensource.org/licenses/MIT.\n*/\nimport { copyResponse } from 'workbox-core/copyResponse.js';\nimport { cacheNames } from 'workbox-core/_private/cacheNames.js';\nimport { getFriendlyURL } from 'workbox-core/_private/getFriendlyURL.js';\nimport { logger } from 'workbox-core/_private/logger.js';\nimport { WorkboxError } from 'workbox-core/_private/WorkboxError.js';\nimport { Strategy } from 'workbox-strategies/Strategy.js';\nimport './_version.js';\n/**\n * A {@link workbox-strategies.Strategy} implementation\n * specifically designed to work with\n * {@link workbox-precaching.PrecacheController}\n * to both cache and fetch precached assets.\n *\n * Note: an instance of this class is created automatically when creating a\n * `PrecacheController`; it's generally not necessary to create this yourself.\n *\n * @extends workbox-strategies.Strategy\n * @memberof workbox-precaching\n */\nclass PrecacheStrategy extends Strategy {\n    /**\n     *\n     * @param {Object} [options]\n     * @param {string} [options.cacheName] Cache name to store and retrieve\n     * requests. Defaults to the cache names provided by\n     * {@link workbox-core.cacheNames}.\n     * @param {Array<Object>} [options.plugins] {@link https://developers.google.com/web/tools/workbox/guides/using-plugins|Plugins}\n     * to use in conjunction with this caching strategy.\n     * @param {Object} [options.fetchOptions] Values passed along to the\n     * {@link https://developer.mozilla.org/en-US/docs/Web/API/WindowOrWorkerGlobalScope/fetch#Parameters|init}\n     * of all fetch() requests made by this strategy.\n     * @param {Object} [options.matchOptions] The\n     * {@link https://w3c.github.io/ServiceWorker/#dictdef-cachequeryoptions|CacheQueryOptions}\n     * for any `cache.match()` or `cache.put()` calls made by this strategy.\n     * @param {boolean} [options.fallbackToNetwork=true] Whether to attempt to\n     * get the response from the network if there's a precache miss.\n     */\n    constructor(options = {}) {\n        options.cacheName = cacheNames.getPrecacheName(options.cacheName);\n        super(options);\n        this._fallbackToNetwork =\n            options.fallbackToNetwork === false ? false : true;\n        // Redirected responses cannot be used to satisfy a navigation request, so\n        // any redirected response must be \"copied\" rather than cloned, so the new\n        // response doesn't contain the `redirected` flag. See:\n        // https://bugs.chromium.org/p/chromium/issues/detail?id=669363&desc=2#c1\n        this.plugins.push(PrecacheStrategy.copyRedirectedCacheableResponsesPlugin);\n    }\n    /**\n     * @private\n     * @param {Request|string} request A request to run this strategy for.\n     * @param {workbox-strategies.StrategyHandler} handler The event that\n     *     triggered the request.\n     * @return {Promise<Response>}\n     */\n    async _handle(request, handler) {\n        const response = await handler.cacheMatch(request);\n        if (response) {\n            return response;\n        }\n        // If this is an `install` event for an entry that isn't already cached,\n        // then populate the cache.\n        if (handler.event && handler.event.type === 'install') {\n            return await this._handleInstall(request, handler);\n        }\n        // Getting here means something went wrong. An entry that should have been\n        // precached wasn't found in the cache.\n        return await this._handleFetch(request, handler);\n    }\n    async _handleFetch(request, handler) {\n        let response;\n        const params = (handler.params || {});\n        // Fall back to the network if we're configured to do so.\n        if (this._fallbackToNetwork) {\n            if (process.env.NODE_ENV !== 'production') {\n                logger.warn(`The precached response for ` +\n                    `${getFriendlyURL(request.url)} in ${this.cacheName} was not ` +\n                    `found. Falling back to the network.`);\n            }\n            const integrityInManifest = params.integrity;\n            const integrityInRequest = request.integrity;\n            const noIntegrityConflict = !integrityInRequest || integrityInRequest === integrityInManifest;\n            // Do not add integrity if the original request is no-cors\n            // See https://github.com/GoogleChrome/workbox/issues/3096\n            response = await handler.fetch(new Request(request, {\n                integrity: request.mode !== 'no-cors'\n                    ? integrityInRequest || integrityInManifest\n                    : undefined,\n            }));\n            // It's only \"safe\" to repair the cache if we're using SRI to guarantee\n            // that the response matches the precache manifest's expectations,\n            // and there's either a) no integrity property in the incoming request\n            // or b) there is an integrity, and it matches the precache manifest.\n            // See https://github.com/GoogleChrome/workbox/issues/2858\n            // Also if the original request users no-cors we don't use integrity.\n            // See https://github.com/GoogleChrome/workbox/issues/3096\n            if (integrityInManifest &&\n                noIntegrityConflict &&\n                request.mode !== 'no-cors') {\n                this._useDefaultCacheabilityPluginIfNeeded();\n                const wasCached = await handler.cachePut(request, response.clone());\n                if (process.env.NODE_ENV !== 'production') {\n                    if (wasCached) {\n                        logger.log(`A response for ${getFriendlyURL(request.url)} ` +\n                            `was used to \"repair\" the precache.`);\n                    }\n                }\n            }\n        }\n        else {\n            // This shouldn't normally happen, but there are edge cases:\n            // https://github.com/GoogleChrome/workbox/issues/1441\n            throw new WorkboxError('missing-precache-entry', {\n                cacheName: this.cacheName,\n                url: request.url,\n            });\n        }\n        if (process.env.NODE_ENV !== 'production') {\n            const cacheKey = params.cacheKey || (await handler.getCacheKey(request, 'read'));\n            // Workbox is going to handle the route.\n            // print the routing details to the console.\n            logger.groupCollapsed(`Precaching is responding to: ` + getFriendlyURL(request.url));\n            logger.log(`Serving the precached url: ${getFriendlyURL(cacheKey instanceof Request ? cacheKey.url : cacheKey)}`);\n            logger.groupCollapsed(`View request details here.`);\n            logger.log(request);\n            logger.groupEnd();\n            logger.groupCollapsed(`View response details here.`);\n            logger.log(response);\n            logger.groupEnd();\n            logger.groupEnd();\n        }\n        return response;\n    }\n    async _handleInstall(request, handler) {\n        this._useDefaultCacheabilityPluginIfNeeded();\n        const response = await handler.fetch(request);\n        // Make sure we defer cachePut() until after we know the response\n        // should be cached; see https://github.com/GoogleChrome/workbox/issues/2737\n        const wasCached = await handler.cachePut(request, response.clone());\n        if (!wasCached) {\n            // Throwing here will lead to the `install` handler failing, which\n            // we want to do if *any* of the responses aren't safe to cache.\n            throw new WorkboxError('bad-precaching-response', {\n                url: request.url,\n                status: response.status,\n            });\n        }\n        return response;\n    }\n    /**\n     * This method is complex, as there a number of things to account for:\n     *\n     * The `plugins` array can be set at construction, and/or it might be added to\n     * to at any time before the strategy is used.\n     *\n     * At the time the strategy is used (i.e. during an `install` event), there\n     * needs to be at least one plugin that implements `cacheWillUpdate` in the\n     * array, other than `copyRedirectedCacheableResponsesPlugin`.\n     *\n     * - If this method is called and there are no suitable `cacheWillUpdate`\n     * plugins, we need to add `defaultPrecacheCacheabilityPlugin`.\n     *\n     * - If this method is called and there is exactly one `cacheWillUpdate`, then\n     * we don't have to do anything (this might be a previously added\n     * `defaultPrecacheCacheabilityPlugin`, or it might be a custom plugin).\n     *\n     * - If this method is called and there is more than one `cacheWillUpdate`,\n     * then we need to check if one is `defaultPrecacheCacheabilityPlugin`. If so,\n     * we need to remove it. (This situation is unlikely, but it could happen if\n     * the strategy is used multiple times, the first without a `cacheWillUpdate`,\n     * and then later on after manually adding a custom `cacheWillUpdate`.)\n     *\n     * See https://github.com/GoogleChrome/workbox/issues/2737 for more context.\n     *\n     * @private\n     */\n    _useDefaultCacheabilityPluginIfNeeded() {\n        let defaultPluginIndex = null;\n        let cacheWillUpdatePluginCount = 0;\n        for (const [index, plugin] of this.plugins.entries()) {\n            // Ignore the copy redirected plugin when determining what to do.\n            if (plugin === PrecacheStrategy.copyRedirectedCacheableResponsesPlugin) {\n                continue;\n            }\n            // Save the default plugin's index, in case it needs to be removed.\n            if (plugin === PrecacheStrategy.defaultPrecacheCacheabilityPlugin) {\n                defaultPluginIndex = index;\n            }\n            if (plugin.cacheWillUpdate) {\n                cacheWillUpdatePluginCount++;\n            }\n        }\n        if (cacheWillUpdatePluginCount === 0) {\n            this.plugins.push(PrecacheStrategy.defaultPrecacheCacheabilityPlugin);\n        }\n        else if (cacheWillUpdatePluginCount > 1 && defaultPluginIndex !== null) {\n            // Only remove the default plugin; multiple custom plugins are allowed.\n            this.plugins.splice(defaultPluginIndex, 1);\n        }\n        // Nothing needs to be done if cacheWillUpdatePluginCount is 1\n    }\n}\nPrecacheStrategy.defaultPrecacheCacheabilityPlugin = {\n    async cacheWillUpdate({ response }) {\n        if (!response || response.status >= 400) {\n            return null;\n        }\n        return response;\n    },\n};\nPrecacheStrategy.copyRedirectedCacheableResponsesPlugin = {\n    async cacheWillUpdate({ response }) {\n        return response.redirected ? await copyResponse(response) : response;\n    },\n};\nexport { PrecacheStrategy };\n", "/*\n  Copyright 2019 Google LLC\n\n  Use of this source code is governed by an MIT-style\n  license that can be found in the LICENSE file or at\n  https://opensource.org/licenses/MIT.\n*/\nimport { assert } from 'workbox-core/_private/assert.js';\nimport { cacheNames } from 'workbox-core/_private/cacheNames.js';\nimport { logger } from 'workbox-core/_private/logger.js';\nimport { WorkboxError } from 'workbox-core/_private/WorkboxError.js';\nimport { waitUntil } from 'workbox-core/_private/waitUntil.js';\nimport { createCacheKey } from './utils/createCacheKey.js';\nimport { PrecacheInstallReportPlugin } from './utils/PrecacheInstallReportPlugin.js';\nimport { PrecacheCacheKeyPlugin } from './utils/PrecacheCacheKeyPlugin.js';\nimport { printCleanupDetails } from './utils/printCleanupDetails.js';\nimport { printInstallDetails } from './utils/printInstallDetails.js';\nimport { PrecacheStrategy } from './PrecacheStrategy.js';\nimport './_version.js';\n/**\n * Performs efficient precaching of assets.\n *\n * @memberof workbox-precaching\n */\nclass PrecacheController {\n    /**\n     * Create a new PrecacheController.\n     *\n     * @param {Object} [options]\n     * @param {string} [options.cacheName] The cache to use for precaching.\n     * @param {string} [options.plugins] Plugins to use when precaching as well\n     * as responding to fetch events for precached assets.\n     * @param {boolean} [options.fallbackToNetwork=true] Whether to attempt to\n     * get the response from the network if there's a precache miss.\n     */\n    constructor({ cacheName, plugins = [], fallbackToNetwork = true, } = {}) {\n        this._urlsToCacheKeys = new Map();\n        this._urlsToCacheModes = new Map();\n        this._cacheKeysToIntegrities = new Map();\n        this._strategy = new PrecacheStrategy({\n            cacheName: cacheNames.getPrecacheName(cacheName),\n            plugins: [\n                ...plugins,\n                new PrecacheCacheKeyPlugin({ precacheController: this }),\n            ],\n            fallbackToNetwork,\n        });\n        // Bind the install and activate methods to the instance.\n        this.install = this.install.bind(this);\n        this.activate = this.activate.bind(this);\n    }\n    /**\n     * @type {workbox-precaching.PrecacheStrategy} The strategy created by this controller and\n     * used to cache assets and respond to fetch events.\n     */\n    get strategy() {\n        return this._strategy;\n    }\n    /**\n     * Adds items to the precache list, removing any duplicates and\n     * stores the files in the\n     * {@link workbox-core.cacheNames|\"precache cache\"} when the service\n     * worker installs.\n     *\n     * This method can be called multiple times.\n     *\n     * @param {Array<Object|string>} [entries=[]] Array of entries to precache.\n     */\n    precache(entries) {\n        this.addToCacheList(entries);\n        if (!this._installAndActiveListenersAdded) {\n            self.addEventListener('install', this.install);\n            self.addEventListener('activate', this.activate);\n            this._installAndActiveListenersAdded = true;\n        }\n    }\n    /**\n     * This method will add items to the precache list, removing duplicates\n     * and ensuring the information is valid.\n     *\n     * @param {Array<workbox-precaching.PrecacheController.PrecacheEntry|string>} entries\n     *     Array of entries to precache.\n     */\n    addToCacheList(entries) {\n        if (process.env.NODE_ENV !== 'production') {\n            assert.isArray(entries, {\n                moduleName: 'workbox-precaching',\n                className: 'PrecacheController',\n                funcName: 'addToCacheList',\n                paramName: 'entries',\n            });\n        }\n        const urlsToWarnAbout = [];\n        for (const entry of entries) {\n            // See https://github.com/GoogleChrome/workbox/issues/2259\n            if (typeof entry === 'string') {\n                urlsToWarnAbout.push(entry);\n            }\n            else if (entry && entry.revision === undefined) {\n                urlsToWarnAbout.push(entry.url);\n            }\n            const { cacheKey, url } = createCacheKey(entry);\n            const cacheMode = typeof entry !== 'string' && entry.revision ? 'reload' : 'default';\n            if (this._urlsToCacheKeys.has(url) &&\n                this._urlsToCacheKeys.get(url) !== cacheKey) {\n                throw new WorkboxError('add-to-cache-list-conflicting-entries', {\n                    firstEntry: this._urlsToCacheKeys.get(url),\n                    secondEntry: cacheKey,\n                });\n            }\n            if (typeof entry !== 'string' && entry.integrity) {\n                if (this._cacheKeysToIntegrities.has(cacheKey) &&\n                    this._cacheKeysToIntegrities.get(cacheKey) !== entry.integrity) {\n                    throw new WorkboxError('add-to-cache-list-conflicting-integrities', {\n                        url,\n                    });\n                }\n                this._cacheKeysToIntegrities.set(cacheKey, entry.integrity);\n            }\n            this._urlsToCacheKeys.set(url, cacheKey);\n            this._urlsToCacheModes.set(url, cacheMode);\n            if (urlsToWarnAbout.length > 0) {\n                const warningMessage = `Workbox is precaching URLs without revision ` +\n                    `info: ${urlsToWarnAbout.join(', ')}\\nThis is generally NOT safe. ` +\n                    `Learn more at https://bit.ly/wb-precache`;\n                if (process.env.NODE_ENV === 'production') {\n                    // Use console directly to display this warning without bloating\n                    // bundle sizes by pulling in all of the logger codebase in prod.\n                    console.warn(warningMessage);\n                }\n                else {\n                    logger.warn(warningMessage);\n                }\n            }\n        }\n    }\n    /**\n     * Precaches new and updated assets. Call this method from the service worker\n     * install event.\n     *\n     * Note: this method calls `event.waitUntil()` for you, so you do not need\n     * to call it yourself in your event handlers.\n     *\n     * @param {ExtendableEvent} event\n     * @return {Promise<workbox-precaching.InstallResult>}\n     */\n    install(event) {\n        // waitUntil returns Promise<any>\n        // eslint-disable-next-line @typescript-eslint/no-unsafe-return\n        return waitUntil(event, async () => {\n            const installReportPlugin = new PrecacheInstallReportPlugin();\n            this.strategy.plugins.push(installReportPlugin);\n            // Cache entries one at a time.\n            // See https://github.com/GoogleChrome/workbox/issues/2528\n            for (const [url, cacheKey] of this._urlsToCacheKeys) {\n                const integrity = this._cacheKeysToIntegrities.get(cacheKey);\n                const cacheMode = this._urlsToCacheModes.get(url);\n                const request = new Request(url, {\n                    integrity,\n                    cache: cacheMode,\n                    credentials: 'same-origin',\n                });\n                await Promise.all(this.strategy.handleAll({\n                    params: { cacheKey },\n                    request,\n                    event,\n                }));\n            }\n            const { updatedURLs, notUpdatedURLs } = installReportPlugin;\n            if (process.env.NODE_ENV !== 'production') {\n                printInstallDetails(updatedURLs, notUpdatedURLs);\n            }\n            return { updatedURLs, notUpdatedURLs };\n        });\n    }\n    /**\n     * Deletes assets that are no longer present in the current precache manifest.\n     * Call this method from the service worker activate event.\n     *\n     * Note: this method calls `event.waitUntil()` for you, so you do not need\n     * to call it yourself in your event handlers.\n     *\n     * @param {ExtendableEvent} event\n     * @return {Promise<workbox-precaching.CleanupResult>}\n     */\n    activate(event) {\n        // waitUntil returns Promise<any>\n        // eslint-disable-next-line @typescript-eslint/no-unsafe-return\n        return waitUntil(event, async () => {\n            const cache = await self.caches.open(this.strategy.cacheName);\n            const currentlyCachedRequests = await cache.keys();\n            const expectedCacheKeys = new Set(this._urlsToCacheKeys.values());\n            const deletedURLs = [];\n            for (const request of currentlyCachedRequests) {\n                if (!expectedCacheKeys.has(request.url)) {\n                    await cache.delete(request);\n                    deletedURLs.push(request.url);\n                }\n            }\n            if (process.env.NODE_ENV !== 'production') {\n                printCleanupDetails(deletedURLs);\n            }\n            return { deletedURLs };\n        });\n    }\n    /**\n     * Returns a mapping of a precached URL to the corresponding cache key, taking\n     * into account the revision information for the URL.\n     *\n     * @return {Map<string, string>} A URL to cache key mapping.\n     */\n    getURLsToCacheKeys() {\n        return this._urlsToCacheKeys;\n    }\n    /**\n     * Returns a list of all the URLs that have been precached by the current\n     * service worker.\n     *\n     * @return {Array<string>} The precached URLs.\n     */\n    getCachedURLs() {\n        return [...this._urlsToCacheKeys.keys()];\n    }\n    /**\n     * Returns the cache key used for storing a given URL. If that URL is\n     * unversioned, like `/index.html', then the cache key will be the original\n     * URL with a search parameter appended to it.\n     *\n     * @param {string} url A URL whose cache key you want to look up.\n     * @return {string} The versioned URL that corresponds to a cache key\n     * for the original URL, or undefined if that URL isn't precached.\n     */\n    getCacheKeyForURL(url) {\n        const urlObject = new URL(url, location.href);\n        return this._urlsToCacheKeys.get(urlObject.href);\n    }\n    /**\n     * @param {string} url A cache key whose SRI you want to look up.\n     * @return {string} The subresource integrity associated with the cache key,\n     * or undefined if it's not set.\n     */\n    getIntegrityForCacheKey(cacheKey) {\n        return this._cacheKeysToIntegrities.get(cacheKey);\n    }\n    /**\n     * This acts as a drop-in replacement for\n     * [`cache.match()`](https://developer.mozilla.org/en-US/docs/Web/API/Cache/match)\n     * with the following differences:\n     *\n     * - It knows what the name of the precache is, and only checks in that cache.\n     * - It allows you to pass in an \"original\" URL without versioning parameters,\n     * and it will automatically look up the correct cache key for the currently\n     * active revision of that URL.\n     *\n     * E.g., `matchPrecache('index.html')` will find the correct precached\n     * response for the currently active service worker, even if the actual cache\n     * key is `'/index.html?__WB_REVISION__=1234abcd'`.\n     *\n     * @param {string|Request} request The key (without revisioning parameters)\n     * to look up in the precache.\n     * @return {Promise<Response|undefined>}\n     */\n    async matchPrecache(request) {\n        const url = request instanceof Request ? request.url : request;\n        const cacheKey = this.getCacheKeyForURL(url);\n        if (cacheKey) {\n            const cache = await self.caches.open(this.strategy.cacheName);\n            return cache.match(cacheKey);\n        }\n        return undefined;\n    }\n    /**\n     * Returns a function that looks up `url` in the precache (taking into\n     * account revision information), and returns the corresponding `Response`.\n     *\n     * @param {string} url The precached URL which will be used to lookup the\n     * `Response`.\n     * @return {workbox-routing~handlerCallback}\n     */\n    createHandlerBoundToURL(url) {\n        const cacheKey = this.getCacheKeyForURL(url);\n        if (!cacheKey) {\n            throw new WorkboxError('non-precached-url', { url });\n        }\n        return (options) => {\n            options.request = new Request(url);\n            options.params = Object.assign({ cacheKey }, options.params);\n            return this.strategy.handle(options);\n        };\n    }\n}\nexport { PrecacheController };\n", "/*\n  Copyright 2019 Google LLC\n\n  Use of this source code is governed by an MIT-style\n  license that can be found in the LICENSE file or at\n  https://opensource.org/licenses/MIT.\n*/\nimport { PrecacheController } from '../PrecacheController.js';\nimport '../_version.js';\nlet precacheController;\n/**\n * @return {PrecacheController}\n * @private\n */\nexport const getOrCreatePrecacheController = () => {\n    if (!precacheController) {\n        precacheController = new PrecacheController();\n    }\n    return precacheController;\n};\n", "/*\n  Copyright 2019 Google LLC\n\n  Use of this source code is governed by an MIT-style\n  license that can be found in the LICENSE file or at\n  https://opensource.org/licenses/MIT.\n*/\nimport { getOrCreatePrecacheController } from './utils/getOrCreatePrecacheController.js';\nimport './_version.js';\n/**\n * Helper function that calls\n * {@link PrecacheController#matchPrecache} on the default\n * {@link PrecacheController} instance.\n *\n * If you are creating your own {@link PrecacheController}, then call\n * {@link PrecacheController#matchPrecache} on that instance,\n * instead of using this function.\n *\n * @param {string|Request} request The key (without revisioning parameters)\n * to look up in the precache.\n * @return {Promise<Response|undefined>}\n *\n * @memberof workbox-precaching\n */\nfunction matchPrecache(request) {\n    const precacheController = getOrCreatePrecacheController();\n    return precacheController.matchPrecache(request);\n}\nexport { matchPrecache };\n", "/*\n  Copyright 2020 Google LLC\n\n  Use of this source code is governed by an MIT-style\n  license that can be found in the LICENSE file or at\n  https://opensource.org/licenses/MIT.\n*/\nimport { setCatchHandler } from 'workbox-routing/setCatchHandler.js';\nimport { matchPrecache } from 'workbox-precaching/matchPrecache.js';\nimport './_version.js';\n/**\n * An implementation of the [comprehensive fallbacks recipe]{@link https://developers.google.com/web/tools/workbox/guides/advanced-recipes#comprehensive_fallbacks}. Be sure to include the fallbacks in your precache injection\n *\n * @memberof workbox-recipes\n *\n * @param {Object} [options]\n * @param {string} [options.pageFallback] Precache name to match for pag fallbacks. Defaults to offline.html\n * @param {string} [options.imageFallback] Precache name to match for image fallbacks.\n * @param {string} [options.fontFallback] Precache name to match for font fallbacks.\n */\nfunction offlineFallback(options = {}) {\n    const pageFallback = options.pageFallback || 'offline.html';\n    const imageFallback = options.imageFallback || false;\n    const fontFallback = options.fontFallback || false;\n    self.addEventListener('install', (event) => {\n        const files = [pageFallback];\n        if (imageFallback) {\n            files.push(imageFallback);\n        }\n        if (fontFallback) {\n            files.push(fontFallback);\n        }\n        event.waitUntil(self.caches\n            .open('workbox-offline-fallbacks')\n            .then((cache) => cache.addAll(files)));\n    });\n    const handler = async (options) => {\n        const dest = options.request.destination;\n        const cache = await self.caches.open('workbox-offline-fallbacks');\n        if (dest === 'document') {\n            const match = (await matchPrecache(pageFallback)) ||\n                (await cache.match(pageFallback));\n            return match || Response.error();\n        }\n        if (dest === 'image' && imageFallback !== false) {\n            const match = (await matchPrecache(imageFallback)) ||\n                (await cache.match(imageFallback));\n            return match || Response.error();\n        }\n        if (dest === 'font' && fontFallback !== false) {\n            const match = (await matchPrecache(fontFallback)) ||\n                (await cache.match(fontFallback));\n            return match || Response.error();\n        }\n        return Response.error();\n    };\n    setCatchHandler(handler);\n}\nexport { offlineFallback };\n"],
  "mappings": "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",
  "names": ["target", "precacheController", "precacheController", "options"]
}
